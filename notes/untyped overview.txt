Instead of referencing wrappers of GL objects just store the GL name. This already works as a reference but is agnostic to the type of the wrapper.

vertex_buffer
    any kind of buffer
    
    name
    
attribute_array
    view of vbo as typed array
    
    vbo, offset, count, stride
    
mesh
    a range into an attribute_array
    
    first, count
    
instance
    an element in an attribute_array storing per instance data

    index
    
vertex_array
    view of array of attribute_arrays as array of typed arrays
    stores attribute divisors for attribute_arrays
    contains additional attribute_array functioning as source GL_DRAW_INDIRECT_BUFFER
    
    allows adding and removing instances and meshes
        this probably only happens a few times every couple of frames
    
    changes to attributes need to be copied to the vao
    changes to draw_commands don't
    
    name
    
call
    points to a vertex_array and a program and allows rendering
    
    also needs to know the number and offset of the draw commands 
    these could be static but could also be dynamic
    
    
mapped_vertex_buffer
    low priority
    
dynamic_attribute_pack_array
    view of a vbo as an array of tuple
    
    provides functions for writing elements
    all writing functions immediately call glBufferSubData to copy changes to the GPU
    
    should this also store the attribute index? Should it be allowed for the same member to appear in different indices in different vaos?
    It wouldn't make sense having to duplicate dynamic_attribute_pack_arrays just to have different indices in vaos.
    The combination of member and vao stores the index. However it should not store the type. The attribute divisor should be stored in dynamic_attribute_pack_array.
    
dynamic_vertex_array
    owns a vao as it needs total control over it
    
    make the vertex_array the object that handles insertions. If several attribute packs provide data for the same call it doesn't make sense to allow them being edited separately.
    
    then where do I store the mapping between attribute arrays and attribute indices?
    is there ever a use to use the same attributes at different indices? let's postpone this for now
    
    sharing dynamic_attribute_pack_arrays between dynamic_vertex_arrays doesn't make sense. dynamic_vertex_array should own the dynamic_attribute_pack_arrays
    
    how do we handle the draw commands?
    a mesh is a contiguous section of a vertex array
    the object handling the vao must be aware of changes to the number of both meshes and instances.
    unless we don't allow reallocations
    if the number of vertices in a mesh is static we don't have to worry about updating vaos
    
vertex_buffer_allocator
    owns a vbo as it needs total control over it
    provides functions to request ranges of the buffer
    
    
